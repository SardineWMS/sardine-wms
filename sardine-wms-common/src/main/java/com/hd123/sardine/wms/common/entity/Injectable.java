/**
 * 版权所有(C)，上海海鼎信息工程股份有限公司，2012，所有权利保留。
 * 
 * 项目名：	sardine-wms-common
 * 文件名：	Injectable.java
 * 模块说明：	
 * 修改历史：
 * 2016-12-12 - zhangsai - 创建。
 */
package com.hd123.sardine.wms.common.entity;

/**
 * 指示类提供从另一个同源对象注入数据的功能。
 * <p>
 * 
 * 这里所说的“同源”是在设计层面上的，判断两个类是否同源的判断依据是，在领域模型是同一个概念。也就是说在领域模型设计阶段是一个概念，
 * 但在设计阶段由于技术上的原因将其分为不同的类，例如持久层对象、服务接口层对象以及界面层对象。
 * 当然作为同源的一个特例，每个类与自己也是同源的，在clone方法中调用inject就是其具体体现。
 * <p>
 * 
 * 所谓“同源”还与继承有关，也就是说父类来自于父概念，子类来资源子概念。相同的父子概念体系会在设计阶段产生某个父子类体系，
 * 也可能由于技术的原因产生不止一个父子类体系。
 * 接下来举例说明：假设在领域模型中存在父概念“动物”，并存在两个子概念“鸟”和“鱼”，并且据此在设计阶段产生父类
 * “Animal”，以及子类“Bird”和“Fish”。
 * 现在的问题是类Bird与类Fish是否同源？直觉告诉我们两者不同源，然而由于它们都是Animal，因此从这个角度讲两者又是同源的。
 * 这就是同源的相对性。换言之在这个例子中，如果将某个Bird对象允许被注入到某个Fish对象，而导致的结果是只有来自于Animal的属性被注入。
 * <p>
 * 
 * 由此，对于接口的实现者而言，如何在实现技术上判断源对象（请参见{@link #inject(Object)}的说明）与当前对象同源？
 * 事实上只需要通过instanceof运算判断传入的源对象是否是设计者认为足以体现同源的类型
 * ，或者说在技术上几乎没有限制，唯一正确与否之取决于使用的类型是否来源于相同的领域模型概念。
 * 因此类型的选择非常关键，实践中通常会使用某些接口或者基类，一般应该尽量避免使用具体类，因为这将导致与这些具体类出现高耦合。
 * 事实上解决同源对象数据复制问题，
 * 还有另一个更好的选择：“com.hd123.rumba.commons.util.converter.Converter”，
 * 即便如此Injectable接口仍有其用武之地，因为在Converter实现类中可以通过调用inject方法简化其实现。
 * 因此推荐如下使用原则：若在技术上存在足以判断同源的接口或基类，建议使用Injectable；否则创建相应的Converter类。
 * <p>
 * 
 * @author zhangsai
 * 
 */
public interface Injectable {

    /**
     * 将指定源对象中的数据注入当前对象中。
     * 
     * @param source
     *            源对象，传入null将不做任何事。
     * @throws UnsupportedOperationException
     *             当具体实现类不支持此操作时抛出。
     */
    public void inject(Object source) throws UnsupportedOperationException;
}
